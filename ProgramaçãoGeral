LOCARES DE DOWLOAD JAVA 17:
- Oracle
- OpenJDK
- Adoptium

AMBIENTE DE LÓGICA:
JAVA SE 17
Eclipse
VSCode
Intellij


JAVA:
- Compila (JAVA C)
- Interpretador (JAVA)

JAVASCRIPT:
- Interpretador

VM = DELTA D (Df - Di) / DELTA T (Tf - Ti)

Constante = que nunca muda
Variante = que sempre pode mudar / Variável é um espaço reservado na mamória do computador para armazenar um tipo de dado determinado.

char: Caracter: O valor armazenado é um caractere. Caracateres geralmente são armazenados em códigos (usualmente)
int: Número inteiro é o tipo padrão e o tamanho do conjunto que pode ser representado normalmente depende da máquina em que o programa está rodando.
float: Número em ponto flutuante de precisão simples. São conhecidos normalmente como números reais.
double: Númeroo em ponto flutuante de precisão dupla
string = Cadeia de caracteres
Bolean: True | False -> Verdadeiro Falso

OPERADORES ARITMÉTICOS:
soma -> +
subtração -> - 
Multiplicação -> x
divisão -> / ou div
resto da divisão -> % ou mod

OPERADORES DE ATRIBUIÇÃO:
igual -> =
Incremento de um -> ++
Decremento de um -> --
Incremento de valor -> +=
Decremento de valor -> -=

OPERADORES LÓGICOS:
E -> && ou AND
Ou -> || ou OR

OPERADORES DE COMPARAÇÃO:
igualdade -> ==
Diferença -> !=
Maior que -> >
Menor que -> <
Maior ou Igual -> >=
Menor ou igual -> <=
     
ESTRUTURA TERNÁRIA
teste ? verdadeiro : falso
int x = 10;
x == 11 ? "oi" : "tchau"

else -> senão

else if -> senão isso, aquilo                    

sempre que tiver if = tem teste

estrutura switch -> alternativa pro if

estruturas de repetição -> for, while, do while -> repetem as coisas por algum tempo que voce determina

while -> mais lento, continua ate chegar no final

for -> mais rapido, mas precisa saber onde termina e nao faz leitura de arquivos

do while (enquanto) -> pode substituir o while, é mais rapido mas precisa de pelo menos uma linha de execução

chaves {} só é obrigatório com mais de uma linha de execução

equals: IGUAL (texto.equals = texto igual)

mult = deslocar o numéro que ta no fundo para frente

string = texto / nomes.

JOptionPane.showMessageDialog(null, "Olá", "Alerta", JOptionPane.WARNING_MESSAGE);
		JOptionPane.showInputDialog("Digite Algo"); 

.equals() = IGUAL ALGO QUE ESTA DENTRO DO PARENTESES

Estruturas Básicas:

- If ... else if ... else:

if ( idade < 18 ) 
	System.out.println("Menores não poderão ser cadastrados")
else
	System.out.println("Cadastro pode ser realizado")
CLASSE: 
if ( valor % 2 == 0 )
	System.out.println("Esse número é par")
else
	System.out.println("Esse número NÃO é par")


if( mes == 12 || mes == 1 || mes == 2)
	System.out.println("Verão");
else if(mes == 3 || mes == 4 || mes == 5)
	System.out.println("Outono");
else if(mes == 6 || mes == 7 || mes == 8)
	System.out.println("Inverno");
else if(mes == 9 || mes == 10 || mes == 11)
	System.out.println("Primavera");
else
	System.out.println("Valor não considerado");

- Switch ... case ... default:

int mes = 5;
 switch(mes){
         case 1:
             System.out.println("Janeiro");
             break;
         case 2:
             System.out.println("Fevereiro");
             break;
         case 3:
             System.out.println("Março");
             break;
         case 4:
             System.out.println("Abril");
             break;
         default:
             System.out.println("Digite SOMENTE números entre 1 e 4");
             break;
}

- for ...e foreach(for):
TABUADA
For ( int i = 1 ; i <= 10 ; i++){
	System.out.println( valor + " x " + i + " = " + (valor * i));
}


For ( int i = 1 ; i <= 10 ; i++){
	if( i % 2 == 0 ){
		System.out.println( i ));
	}
}


- while ...:

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
 
public class Ler{
    public static void main(String[] args) throws IOException{
        String arquivo = "texto.txt";
            FileReader in = new FileReader(arquivo);
            StringBuilder conteudo = new StringBuilder();
            char[] buffer = new char[4096];
            int read = 0;
        do {
            conteudo.append(buffer, 0, read);
            read = in.read(buffer);
        } while (read >= 0);
        in.close();
        System.out.println(conteudo.toString());
    }
}

- array/[] (vetor e matriz): Um array é um conjunto de dados de tipo semelhante que são referidas por um nome comum como um váriavel. Array de
qualquer tipo pode ser criado e pode ter uma ou mais dimensões(GUARDA MAIS DE UM VALOR). Um elemento específico em um array
é acessado pelo seu índice. Arrays oferecem um meio conveniente de agrupar informações relacionadas.
(obs: sempre contar posição começando pelo 0, ex: 15(0), 26(1) , 31(2), 5(3), 20(4); QUANTIDADE - 1)
int[] valores = {15,26,31,5,20}
System.out.println(valor[2]);

Array de 2 dimensões(TABELAS). Exemplo:
String[][] dados = {
			{"Id","Produto","Preço"},
			{"45","Calça","R$ 110.00"},
			{"14","Blusa","R$ 23,50"}
		}
	System.out.println(dados[0][2])
- metodos.

ARRAY COM 1 LINHA = VETOR ([])
ARRAY COM MAIS DE UMA LINHA = MATRIZ ([][])

/r = serve para fazer retornar
/n = como se fosse enter
println = um embaixo do outro (quebra linha)
print = fica na mesma linha

FUNÇÃO:
- A principal característica é a utilização de técnicas que decompõem a
- Solução de um problema em “blocos” que interagem com um bloco principal. Isso é possível por meio da técnica de refinamentos sucessivos e da modularização dos algoritmos.
- Você pode inserir funções em seus algoritmos, baste ter bem definido o que qual parte da estrutura de código se pretende modularizar.
- As ações de função estão hierarquicamente subordinadas a um algoritmo principal. Dentro de uma função, pode haver o chamamento de outras funções
Há quatro tipos de funções:
	Função sem retorno e argumentos;       (TAMBÉM CONHECIDA COMO PROCEDIMENTO)
	Função sem retorno e com argumentos;   (TAMBÉM CONHECIDA COMO PROCEDIMENTO)


	Função com retorno e sem argumentos;
	Função com retorno e com argumentos;
	
CARACTERÍSTICAS:
- As funções quando não possuem retorno, em C#, elas são declaradas como VOID – vazio. 
- Funções com retorno deve ter o tipo de retorno declarado diferente de VOID.
- Outro ponto que devemos destacar é que toda função deve possuir um nome e seguido por parênteses. Esses, por sua vez, podem conter algo ou não.
- Os elementos presentes nos parênteses são chamados de ARGUMENTOS. Muitas pessoas chamam de parâmetros. 
- Para que uma função faça as suas execuções é necessário “chama-la”, ou seja, escrever o nome da função no momento em que for utilizá-la.
- VOID - SAIDA ESPECIFICADA
EXEMPLOS:
Função SEM RETORNO E SEM ARGUMENTOS:

void mensagem(){
Console.WriteLine(“Olá! Seja bem vindo!”);
}

Função SEM RETORNO E COM ARGUMENTOS:

void mensagem(String nome){
Console.WriteLine(“Olá, Sr(a): “ + nome + “! Seja bem vindo!”);
}

Função COM RETORNO E SEM ARGUMENTOS:
Double valorPI(){
	return 3.1415
}

Função COM RETORNO E COM ARGUMENTOS:

Int areaDoRetangulo(int largura, int altura){
	int resultado;
	resultado  = largura * altura;
	return resultado
}

TRY CATCH:
A instrução try-catch consiste em um bloco try seguido por uma ou mais
cláusulas catch, que especificam os manipuladores para diferentes exceções.

O bloco try contém o código protegido que pode causar a exceção.
O bloco é executado até que uma exceção seja lançada ou ele seja
concluído com êxito. 

try{
    //comandos
}
catch{
    //comandos
}

EXEMPLO TRY CATCH:
Conversão de tipos, Divisão por Zero, Escrita em arquivos. 

object o2 = null;  

try  
{  
    int i2 = (int)o2;   // Error  
}
catch (FileNotFoundException e){ 
	//comandos 
} 
catch (IOException e) {
	//comandos 
} 

EXEMPLO TRY CATCH - FINALLY:
Conversão de tipos, Divisão por Zero, Escrita em arquivos. 

object o2 = null;  

try  
{  
	StreamWriter sw = new StreamWriter(“Arquivo.txt”)
	sw.close(); (TEM QUE USAR ESSE COMANDO PARA FECHAR NO FINALLY)
	sw.WriteLine(“teste”);
}
catch (Exception ex){ 
	//comandos 
} 
finally{
	//comandos (ex: sw.close();)
} 

CALCULAR CPF:
Para exemplificar o precesso, vamos gerar um CPF válido, calculando os digitos verificadores de um número hipotético, 111.444.777-XX

Calculando o primeiro digito verificador:
O primeiro dígito verificador do CPF é calculado utilizando-se o seguinte algoritmo.

1) ) Distribua os 9 primeiros dígitos em um quadro colocando os pesos 10, 9, 8, 7, 6, 5, 4, 3, 2 abaixo da 
esquerda para a direita, conforme representação abaixo:
	1 1 1 4 4 4 7 7 7
	10 9 8 7 6 5 4 3 2

2) Multiplique os valores de cada coluna:
	1 1 1 4 4 4 7 7 7
	10 9 8 7 6 5 4 3 2
	10 9 8 28 24 20 28 21 14

3) Calcule o somatório dos resultados (10+9+...+21+14) = 162


4) O resultado obtido (162) será divido por 11. Considere como quociente apenas o valor inteiro, o resto 
da divisão será responsável pelo cálculo do primeiro dígito verificador.
	Vamos acompanhar: 162 dividido por 11 obtemos 14 como quociente e 8 como resto da divisão. Caso o 
resto da divisão seja menor que 2, o nosso primeiro dígito verificador se torna 0 (zero), caso contrário 
subtrai-se o valor obtido de 11, que é nosso caso. Sendo assim nosso dígito verificador é 11-8, ou seja, 3 
(três). Já temos portanto parte do CPF, confira: 111.444.777-3X.

Calculando o Segundo Dígito Verificador:
	
	1) Para o cálculo do segundo dígito será usado o primeiro dígito verificador já calculado. Montaremos 
uma tabela semelhante a anterior só que desta vez usaremos na segunda linha os valores 
11,10,9,8,7,6,5,4,3,2 já que estamos incorporando mais um algarismo para esse cálculo. Veja:
	1 1 1 4 4 4 7 7 7 3
	11 10 9 8 7 6 5 4 3 2

2) Na próxima etapa faremos como na situação do cálculo do primeiro dígito verificador, multiplicaremos 
os valores de cada coluna e efetuaremos o somatório dos resultados obtidos: (11+10+...+21+6) = 204.
	1 1 1 4 4 4 7 7 7 3
	11 10 9 8 7 6 5 4 3 2
	11 10 9 32 28 24 35 28 21 6

3) Realizamos novamente o cálculo do módulo 11. Dividimos o total do somatório por 11 e 
consideramos o resto da divisão.
Vamos acompanhar: 204 dividido por 11 obtemos 18 como quociente e 6 como resto da divisão.

4) Caso o valor do resto da divisão seja menor que 2, esse valor passa automaticamente a ser zero, caso 
contrário (como no nosso caso) é necessário subtrair o valor obtido de 11 para se obter o dígito 
verificador. Logo, 11-6= 5, que é o nosso segundo dígito verificador.
Neste caso chegamos ao final dos cálculos e descobrimos que os dígitos verificadores do nosso CPF 
hipotético são os números 3 e 5, portanto o CPF ficaria assim: 111.444.777-35


ORIENTAÇÃO OBJETO:
- Classes;
- Objetos;
- Métodos;
- String;
- Operadores de atribuição;
- Operadores Lógicos;
- Operadores relacionais;

Classes:  Declaração de classe

//public class Usuario :
		
- A palavra-chave é um modificador de acesso. Por enquanto, simplesmente declaramos toda classe public. Cada declaração de classe public deve ser armazenada em um arquivo com o mesmo nome que a classe e terminar com a extensão .java; do contrário, ocorrerá um erro de compilação

- Cada declaração de classe contém a palavra-chave class seguida imediatamente pelo nome da classe, nesse caso, Usuario. Cada corpo de classe é inserido entre um par de chaves esquerda e direita, ou seja, abertura e fechamento {    .....    }

- Nomes de classes, de método e de variável são identificadores e, por convenção, todos usam o mesmo esquema de nomeação com a notação camelo. Também por convenção, os nomes de classe começam com uma letra maiúscula, e os de métodos e de variáveis iniciam com uma letra minúscula

//Variável de instância login :

Um objeto tem atributos, implementados como variáveis de instância que o acompanham ao longo da sua vida. As variáveis de instância existem antes que os métodos sejam chamados em um objeto, enquanto eles são executados e depois que a execução deles foi concluída. Cada objeto (instância) da classe tem sua própria cópia das variáveis de instância da classe. Uma classe normalmente contém um ou mais métodos que manipulam as variáveis de instância pertencentes aos objetos particulares dela. Variáveis de instância são declaradas dentro de uma declaração de classe, mas fora do corpo dos métodos da classe. 

	Veja um exemplo:
		public class Usuario{
			private String login;
			private String senha;
			public void logar(){ .... } 
		}

//Parâmetros :
São variáveis locais que declaramos dentro de um aplicativo no método. Variáveis declaradas no corpo de um método específico (como login) são variáveis locais que somente podem ser utilizadas nele. Cada método só pode acessar suas próprias variáveis locais, não aquelas dos outros. Quando esse método terminar, os valores de suas variáveis locais são perdidos. Os parâmetros de um método também são variáveis locais dele. 
public class Usuario{
private String login;
public void logar(nomeUsuario){

}
public void cadastrar(){

 nomeUsuario = “Pedro”;
}

Objetos:

Como mencionado anteriormente, uma classe fornece os esquemas para objetos. Então, basicamente, um objeto é criado a partir de uma classe. 

Em Java, a new palavra-chave é usada para criar novos objetos. Existem três etapas ao criar um objeto de uma classe:
	 - Declaração - Uma declaração de variável com um nome de variável com um tipo de 	objeto.
	- Instantiation - A palavra-chave 'new' é usada para criar o objeto.
	- Inicialização - A palavra-chave 'new' é seguida por uma chamada para um construtor. 

	Esta chamada inicializa o novo objeto. 

//Instância de um objeto — palavra-chave new e construtores :

Usuario us = new Usuario();

O exemplo acima a variável us é inicializada com o resultado da expressão de criação de instância de classe new Usuario(). A palavra-chave new estabelece um novo objeto da classe especificada — nesse caso, Usuario. Os parênteses à direita de Usuario são necessários. Esses parênteses em combinação com um nome de classe representam uma chamada para um construtor, que é semelhante a um método, mas é chamado implicitamente pelo operador new para inicializar as variáveis de instância de um objeto quando este é criado. Você ainda pode colocar um argumento entre os parênteses para especificar um valor inicial a uma variável de instância

//Construtores

Ao discutir sobre classes, um dos subtópicos mais importantes seria construtores. Toda classe tem um construtor. Se não escrevermos explicitamente um construtor para uma classe, o compilador Java construirá um construtor padrão para essa classe. 
Cada vez que um novo objeto é criado, pelo menos um construtor será invocado.
A principal regra dos construtores é que eles devem ter o mesmo nome da classe. 

Uma classe pode ter mais de um construtor.

Métodos: 

Um método Java é uma coleção de instruções que são agrupadas para executar uma operação. Quando você chama o método System.out.println (), por exemplo, o sistema na verdade executa várias instruções para exibir uma mensagem no console. 
Agora você aprenderá como criar seus próprios métodos com ou sem valores de retorno, invocar um método com ou sem parâmetros e aplicar abstração de método no design do programa. 


public void soma(){
    System.out.println(50+60);
}

public void soma(int x, int y){					
   System.out.println(x+y);
}

public int soma(){                      }>  CHAMADA   }>    soma(); -> Sem Retorno
   return 50+60;						
}							    int rs;
							    rs = soma(30,40) -> Com Retorno
public int soma(int x, int y){
   return x+y;
}

//Elementos que compoe um método:

Modificador - Define o tipo de acesso do método e é opcional para uso. 
Tipo de Retorno - O método pode retornar um valor.
Nome do Método - Esse é o nome do método. 
A assinatura do método consiste no nome do método e na lista de parâmetros.
Lista de Parâmetros - A lista de parâmetros, é o tipo, ordem e número de parâmetros de um método. Estes são opcionais, o método pode conter zero parâmetros.
Corpo do método - O corpo do método define o que o método faz com as instruções. 

public String msgParaUsuario(String nome, int idade){
	return "Olá", "+nome+", você tem "+idade+"anos"; }
Public(Modificador) String(Tipo de retorno) msgParaUsuario(Nome do método) (String nome(Parâmetros), int idade(Argumentos)){
	return "Olá", "+nome+", você tem "+idade+"anos"; (CORPO DO MÉTODO) }
	
Operadores Relacionais:

operadores de igualdade 
== = x é igual a y
!= - x não é igual a y

operadores relacionais:
> = x é maior que y
< = x é menos que y
>= = x é maior ou igual a y
<= = x é menor que ou igual a y

Operadores Scape:

/n = Nova linha. Posiciona o cursos de tela no início da próxima linha
/t = Tabulação horizontal. Move o cursor para a próxima parada de tabulação
/r = Retorno de carro. Posiciona o cursos no início da linha atual

\\ = Barras invertidas. Utilizadas para imprimir um caractere de barra invertida
\"" = Aspas duplas. Utilizadas para imprimir um caractere de aspas duplas. Por exemplo, exibe "entre aspas".

Operadors Aritméticas:

Adição =   +  /   f + 7
Subtração =  -  /  p - c
Multiplicação =  *  /  b * m
Divisão =  /  /  x / y
Resto =  %  /  r % s
